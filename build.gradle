/*
  JavaFX Boilerplate Project

  https://github.com/akman/javafx-boilerplate

  MIT License (MIT)

  Copyright (C) 2019 - 2021 Alexander Kapitman <akman.ru@gmail.com>

  Permission is hereby granted, free of charge, to any person obtaining
  a copy of this software and associated documentation files (the "Software"),
  to deal in the Software without restriction, including without limitation
  the rights to use, copy, modify, merge, publish, distribute, sublicense,
  and/or sell copies of the Software, and to permit persons to whom
  the Software is furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included
  in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFINGEMENT. IN NO EVENT SHALL
  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  DEALINGS IN THE SOFTWARE.
*/

// https://plugins.gradle.org/search
plugins {
  // https://docs.gradle.org/current/userguide/application_plugin.html
  id 'application'
  // https://docs.gradle.org/current/userguide/groovy_plugin.html
  id 'groovy'
  // https://docs.gradle.org/current/userguide/eclipse_plugin.html
  id 'eclipse'
  // https://docs.gradle.org/current/userguide/project_report_plugin.html
  id 'project-report'
  // https://docs.gradle.org/current/userguide/build_dashboard_plugin.html
  id 'build-dashboard'
  // https://docs.gradle.org/current/userguide/checkstyle_plugin.html
  // https://checkstyle.org/index.html
  id 'checkstyle'
  // https://docs.gradle.org/current/userguide/pmd_plugin.html
  // https://pmd.github.io/latest/
  id 'pmd'
  // https://docs.gradle.org/current/userguide/codenarc_plugin.html
  // https://codenarc.github.io/CodeNarc/
  id 'codenarc'
  // https://docs.gradle.org/current/userguide/jacoco_plugin.html
  // https://www.eclemma.org/jacoco/
  id 'jacoco'
  // https://github.com/aaschmid/gradle-cpd-plugin
  id 'de.aaschmid.cpd' version '3.3'
  // https://github.com/spotbugs/spotbugs-gradle-plugin
  id 'com.github.spotbugs' version '4.7.5'
  // https://badass-jlink-plugin.beryx.org
  // https://github.com/beryx/badass-jlink-plugin
  id 'org.beryx.jlink' version '2.24.2'
  // https://github.com/hierynomus/license-gradle-plugin
  id 'com.github.hierynomus.license' version '0.16.1'
  // https://github.com/ben-manes/gradle-versions-plugin
  id 'com.github.ben-manes.versions' version '0.39.0'
  // https://github.com/researchgate/gradle-release
  id 'net.researchgate.release' version '2.8.1'
  // https://github.com/Akman/vscode-tasks
  id 'ru.akman.vscode-tasks' version '0.4.0'
}

repositories {
  mavenCentral()
}

ext {
  
  // Gradle
  gradleVersion = '7.2'
  if (GradleVersion.current() < GradleVersion.version(gradleVersion)) {
    logger.warn("WARNING: Gradle version '${gradleVersion}' or higher is required.")
  }

  // Java
  javaVersion = JavaVersion.VERSION_16

  // Encoding
  defaultEncoding = 'UTF-8'

  // Tools
  checkstyleVersion = '9.0'
  pmdVersion = '6.38.0'
  spotbugsVersion = '4.4.1'
  codenarcVersion = '2.2.0'
  jacocoVersion = '0.8.7'

  // Dependencies  
  javafxVersion = '16'
  picocliVersion = '4.6.1'
  slf4jVersion = '2.0.0-alpha5'
  logbackVersion = '1.3.0-alpha10'
  junitVersion = '5.8.0'
  spockVersion = '2.0-groovy-3.0'
  mockitoVersion = '3.12.4'
  groovyVersion = '3.0.9'
  hamcrestVersion = '2.2'
  assertjVersion = '3.16.1'

  // Application
  applicationName = 'JavaFX Boilerplate Project'
  applicationVersion = project.version.replaceAll('-SNAPSHOT', '')
  applicationFullName = "${applicationName} v${applicationVersion}"
  applicationDescription = 'JavaFX application boilerplate project using gradle and maven build tools. This project aims to cover best practices for JavaFX application development as a whole. It provides tool recommendations for linting, testing and packaging.'
  applicationScmUser = 'akman'
  applicationScmRepo = 'javafx-boilerplate'
  applicationUrl = "https://github.com/${applicationScmUser}/${applicationScmRepo}"
  applicationInceptionYear = 2019
  applicationCurrentYear = Calendar.getInstance().get(Calendar.YEAR)
  applicationAuthorNickname = 'Akman'
  applicationAuthorName = 'Alexander Kapitman'
  applicationAuthorEmail = 'akman.ru@gmail.com'
  applicationAuthorUrl = 'https://akman.github.io/'
  applicationAuthorRole = 'developer'
  applicationAuthorTimezone = 'Europe/Kaliningrad'
  applicationCopyright = "Copyright (C) ${applicationInceptionYear}"
  if (applicationInceptionYear != applicationCurrentYear) {
    applicationCopyright += " - ${applicationCurrentYear}"
  }
  applicationCopyright += " ${applicationAuthorName}";
  applicationCopyright += " <${applicationAuthorEmail}>";
  applicationVendor = 'Akman'
  applicationVendorUrl = 'https://akman.github.io/'
  applicationLicenseFile = 'LICENSE'
  applicationLicenseName = 'MIT License'
  applicationLicenseType = 'MIT'
  applicationLicenseDistribution = 'repo'
  applicationLicenseComment = 'This is a lax, permissive non-copyleft free software license, compatible with the GNU GPL.'
  applicationLicenseUrl = 'https://spdx.org/licenses/MIT.html'

  // Launcher
  applicationLauncherName = 'launcher'
  applicationModuleName = 'ru.akman.launcher'
  applicationClassName = 'ru.akman.launcher.Launcher'
  applicationJvmArgs = [
    '-Xms256m',
    '-Xmx512m',
  ]
  applicationArgs = [
    '--debug'
  ]
  applicationSplashImage = 'splash.png'

  // Platform
  os = org.gradle.internal.os.OperatingSystem.current()
  platformModifier = os.isWindows() ? 'win' : (os.isLinux() ? 'linux' : 'mac')
  platformFamily = os.isWindows() ? 'windows' : (os.isLinux() ? 'linux' : 'mac')

  switch (platformFamily) {
    case 'windows':
      platformImageName = 'Launcher'
      platformIconExtension = 'ico'
      platformLauncherName = "${applicationLauncherName}"
      platformArgs = applicationArgs + [
        '--gui'
      ]
      platformJvmArgs = applicationJvmArgs + [
        "-Dfile.encoding=${defaultEncoding}",
      ]
      platformInstallDir = "${applicationVendor}/${platformImageName}"
      platformMenuGroup = "${applicationVendor}/${platformImageName}"
      platformUUID = '8CF81762-0B19-46A6-875E-1F839A1700D0'
      break
    case 'linux':
      platformImageName = 'Launcher'
      platformIconExtension = 'png'
      platformLauncherName = "${applicationLauncherName}"
      platformArgs = applicationArgs + [
        '--gui'
      ]
      platformJvmArgs = applicationJvmArgs + [
          "-Dfile.encoding=${defaultEncoding}",
      ]
      platformInstallDir = "/opt/${applicationVendor}/${platformImageName}"
      platformMenuGroup = "${applicationVendor}/${platformImageName}"
      platformUUID = ''
      break
    case 'mac':
      platformImageName = 'Launcher'
      platformIconExtension = 'icns'
      platformLauncherName = "${applicationLauncherName}"
      platformArgs = applicationArgs + [
        '--gui'
      ]
      platformJvmArgs = applicationJvmArgs + [
          "-Dfile.encoding=${defaultEncoding}",
      ]
      platformInstallDir = "/Applications/${applicationVendor}/${platformImageName}"
      platformMenuGroup = "${applicationVendor}/${platformImageName}"
      platformUUID = ''
      break
  }

  // JLink
  jlinkConfigDir = "${projectDir}/package"
  jlinkTemplateWin = "${jlinkConfigDir}/win-script.template"
  jlinkTemplateNix = "${jlinkConfigDir}/nix-script.template"
  jlinkDir = "${buildDir}/jlink"
  jlinkModsDir = "${jlinkDir}/mods"
  jlinkLibsDir = "${jlinkDir}/libs"
  jlinkImageDir = "${jlinkDir}/runtime-image"

  // JPackage
  jpackageConfigDir = "${projectDir}/package/${platformFamily}"
  jpackageInputDir = "${jpackageConfigDir}/input"
  jpackageResourcesDir = "${jpackageConfigDir}/resources"
  jpackageDir = "${buildDir}/jpackage"
  jpackageImageDir = "${jpackageDir}/${platformImageName}"

  // Log
  logDir = file("${projectDir}/log")
}

dependencies {
  annotationProcessor(
    "info.picocli:picocli-codegen:${picocliVersion}"
  )
  implementation(
    // JavaFX
    "org.openjfx:javafx-base:${javafxVersion}:${platformModifier}",
    "org.openjfx:javafx-controls:${javafxVersion}:${platformModifier}",
    "org.openjfx:javafx-graphics:${javafxVersion}:${platformModifier}",
    "org.openjfx:javafx-fxml:${javafxVersion}:${platformModifier}",
    "org.openjfx:javafx-swing:${javafxVersion}:${platformModifier}",
    //"org.openjfx:javafx-web:${javafxVersion}:${platformModifier}",
    //"org.openjfx:javafx-media:${javafxVersion}:${platformModifier}",
    // Picocli
    "info.picocli:picocli:${picocliVersion}",
    // SLF4J + Logback
    "org.slf4j:slf4j-api:${slf4jVersion}",
    "ch.qos.logback:logback-classic:${logbackVersion}",
  )
  testImplementation(
    // JUpiter
    "org.junit.jupiter:junit-jupiter-api:${junitVersion}",
    // Spock
    "org.spockframework:spock-core:${spockVersion}",
    // Mockito
    "org.mockito:mockito-junit-jupiter:${mockitoVersion}",
    // Hamcrest
    // "org.hamcrest:hamcrest:${hamcrestVersion}",
    // AssertJ
    // "org.assertj:assertj-core:${assertjVersion}",
  )
  testRuntimeOnly(
    // JUnit 5
    "org.junit.jupiter:junit-jupiter-engine:${junitVersion}",
  )
}

java {
  sourceCompatibility = javaVersion
  targetCompatibility = javaVersion
  modularity.inferModulePath = true
}

application {
  mainModule = applicationModuleName
  mainClass = applicationClassName
  applicationDefaultJvmArgs = platformJvmArgs
  applicationName = platformImageName
}

eclipse {
  classpath {
    containers 'org.eclipse.buildship.core.gradleclasspathcontainer'
    file {
      whenMerged {
        entries
            .findAll {
              it.properties.kind.equals('lib') &&
                  !it.properties.path.contains("junit")
            }
            .each {
              it.entryAttributes['module'] = 'true'
            }
        entries
            .findAll {
              it.properties.path.startsWith(
                  'org.eclipse.jdt.launching.JRE_CONTAINER')
            }
            .each {
              it.entryAttributes['module'] = 'true'
            }
      }
    }
  }
}

clean {
  delete "${logDir}"
}

[compileGroovy, compileTestGroovy]*.options*.encoding = defaultEncoding

[compileJava, compileTestJava].each {
  it.options.encoding = defaultEncoding
  it.options.compilerArgs += [
    // Give more detail for unchecked conversion warnings that are mandated
    // by the Java Language Specification.
    '-Xlint:unchecked',
    // Show a description of each use or override of a deprecated member
    // or class. Without this, javac shows a summary of the source files
    // that use or override deprecated members or classes.
    '-Xlint:deprecation',
    // Terminate compilation if warnings occur.
    '-Werror',
    // Picocli annotation processor
    "-Aproject=${project.group}/${project.name}"
  ]
}

task processCommonResources(type: Copy) {
  description = 'Processes common resources'
  from "${projectDir}/config/readme/README.md"
  into projectDir
  expand project.properties
}

task processFilteredResources(type: Copy) {
  description = 'Processes filtered resources'
  sourceSets.main.resources.srcDirs.each {
    def filteredDir = new File(it, 'filtered')
    def filtersDir = new File(it, 'filters')
    def filterFile = new File(filtersDir, 'filter.properties')
    def filter = new ru.akman.utils.PropertiesMap(filterFile)
    from filteredDir
    into sourceSets.main.output.resourcesDir
    expand filter.properties + project.properties + System.properties
  }
}

processResources {
  dependsOn processFilteredResources
  exclude 'filtered/', 'filters/'
}

task processFilteredTestResources(type: Copy) {
  description = 'Processes filtered test resources'
  sourceSets.test.resources.srcDirs.each {
    def filteredDir = new File(it, 'filtered')
    def filtersDir = new File(it, 'filters')
    def filterFile = new File(filtersDir, 'filter.properties')
    def filter = new ru.akman.utils.PropertiesMap(filterFile)
    from filteredDir
    into sourceSets.test.output.resourcesDir
    expand filter.properties + project.properties + System.properties
  }
}

processTestResources {
  dependsOn processFilteredTestResources
  exclude 'filtered/', 'filters/'
}

test {
  useJUnitPlatform()
  failFast = true
  jvmArgs = [
    "-Dfile.encoding=${defaultEncoding}",
  ]
  reports {
    html.enabled = true
  }
}

tasks.withType(Test) {
  testLogging {
    showExceptions = true
    showCauses = true
    showStackTraces = true
    displayGranularity = 2
    exceptionFormat = 'short'
    showStandardStreams = true
    events(
      // 'started',
      'passed',
      'skipped',
      'failed',
      // org.gradle.api.tasks.testing.logging.TestLogEvent.STANDARD_ERROR,
      // org.gradle.api.tasks.testing.logging.TestLogEvent.STANDARD_OUT,
    )
    debug {
      displayGranularity = 0
      exceptionFormat = 'full'
      events(
        'started',
        'passed',
        'skipped',
        'failed',
      )
    }
  }
}

javadoc {
  failOnError = false
  options.encoding defaultEncoding
  options.addStringOption 'bottom', applicationCopyright
  options.addBooleanOption 'html5', true
  options.addBooleanOption 'notimestamp', true
}

jar {
  manifest {
    attributes(
      'Main-Class': "${applicationClassName}",
      'Specification-Title': "${applicationName}",
      'Specification-Version': "${project.version}",
      'Specification-Vendor': "${applicationVendor}",
      'Implementation-Title': "${applicationModuleName}",
      'Implementation-Version': "${project.version}",
      'Implementation-Vendor': "${applicationVendor}",
      'SplashScreen-Image': "${applicationSplashImage}",
    )
  }
}

task fatJar(type: Jar) {
  archiveAppendix = 'full'
  manifest {
    attributes(
      'Main-Class': "${applicationClassName}",
      'Specification-Title': "${applicationName}",
      'Specification-Version': "${version}",
      'Specification-Vendor': "${applicationVendor}",
      'Implementation-Title': "${applicationModuleName}",
      'Implementation-Version': "${version}",
      'Implementation-Vendor': "${applicationVendor}",
      'SplashScreen-Image': "${applicationSplashImage}",
    )
  }
  duplicatesStrategy = DuplicatesStrategy.INCLUDE
  from {
    configurations.runtimeClasspath.collect {
      it.isDirectory() ? it : zipTree(it)
    }
  }
  with jar
}

task sourcesJar(type: Jar, dependsOn: classes) {
  classifier 'sources'
  from sourceSets.main.allSource
}

task javadocJar(type: Jar, dependsOn: classes) {
  classifier 'javadoc'
  from javadoc
}

artifacts {
  archives sourcesJar, javadocJar, fatJar
}

distributions {
  main {
    contents {
      from(javadocJar) {
        into 'docs'
      }
      from(sourcesJar) {
        into 'docs'
      }
    }
  }
}

// startScripts {
//   doFirst {
//     defaultJvmOpts = [
//     ]
//   }
//   doLast{
//     def bashFile = new File(outputDir, applicationLauncherName)
//     String bashContent = bashFile.text
//     bashFile.text = bashContent
//         .replaceFirst(/(?m)^media\/gradle\.icns$/, 'media/app.icns')
//     def batFile = new File(outputDir, applicationLauncherName + ".bat")
//     String batContent = batFile.text
//     batFile.text = batContent
//         .replaceFirst(/(?m)^media\/gradle\.icns$/, 'media/app.icns')
//   }
// }

run {
  standardInput = System.in
  jvmArgs = platformJvmArgs
  args = platformArgs
}

// task exec(type: ru.akman.utils.ExecTask) {
//   description 'Executes this project as a JVM application'
//   group 'application'
//   dependsOn classes
//   standardInput = System.in
//   executable = org.gradle.internal.jvm.Jvm.current().javaExecutable
//   args = platformJvmArgs
//   args += [
//     '-Dfile.encoding=' + System.properties['file.encoding'],
//     '-Duser.country=' + System.properties['user.country'],
//     '-Duser.language=' + System.properties['user.language'],
//     '-Duser.variant=' + System.properties['user.variant'],
//   ]
//   args += [
//     '--module-path', files(sourceSets.main.runtimeClasspath).asPath,
//     '--patch-module', "${applicationModuleName}=" +
//         files(sourceSets.main.output.resourcesDir).asPath,
//     '--module', "${applicationModuleName}/${applicationClassName}",
//   ]
//   args += platformArgs
// }

release {

  // Fail when there un-committed changes.
  failOnCommitNeeded = true

  // Fail when there are local commits that haven't been published upstream.
  failOnPublishNeeded = true

  // Fail when the project has dependencies on SNAPSHOT versions unless
  // those SNAPSHOT dependencies have been defined
  // as 'ignoredSnapshotDependencies' using the syntax '$group:$name'.
  failOnSnapshotDependencies = true

  // Fail when files are found that are not under version control.
  failOnUnversionedFiles = true

  // Fail when the source needs to be updated, or there are changes
  // available upstream that haven't been pulled.
  failOnUpdateNeeded = true

  // Should the plugin revert it's changes to gradle.properties
  // when a failure occurs.
  revertOnFail = true

  // The string template which is used to generate the tag name.
  // Possible variables are $version and $name.
  // Always ensure to use single-quotes, otherwise "$" is interpreted
  // already in your build script.
  tagTemplate = 'v${version}'

  // This will be prepended to all commits done by the plugin.
  // A good place for code review, or ticket numbers.
  preCommitText = ''

  // The commit message used to commit the non-SNAPSHOT version
  // if SNAPSHOT was used.
  preTagCommitMessage = 'SNAPSHOT was used to commit the non-SNAPSHOT version'

  // The commit message used when creating the tag.
  // Not used with BZR projects.
  tagCommitMessage = 'Release version'

  // The commit message used when committing the next version.
  newVersionCommitMessage = 'Bump version'

  versionPropertyFile = 'gradle.properties'

  versionProperties = []

  versionPatterns = [
    /(\d+)\.(\d+)\.(\d+)(.*$)/: { java.util.regex.Matcher m, Project p ->
        m.replaceAll("${m[0][1]}.${(m[0][2] as int) + 1}.0${m[0][4]}") },
  ]

  buildTasks = [
    'clean',
    'check',
    'jacocoTestReport',
  ]

  ignoredSnapshotDependencies = []

  // (GIT only) If set to the name of a branch, the "release" task will
  // commit the release on this branch, and the next version
  // on the working branch.
  pushReleaseVersionBranch = false

  git {

    // Defines the branch which releases must be done off of.
    // Eg. set to "release" to require releases are done on
    // the "release" branch (or use a regular expression to allow releases
    // from multiple branches, e.g. "/release|master/").
    // Set to '' to ignore.
    requireBranch = 'master'

    pushToBranchPrefix = ''

    pushToRemote = 'origin'

    commitVersionFileOnly = false

    // Adds `-s` parameter to the tag command
    signTag = false

    // Defines an array of options to add to the git adapter during a push.
    // This could be useful to have the vc hooks skipped during a release.
    // pushOptions = [
    //   '--no-verify',
    // ]

  }

}

////////////////////////////////////////////////////////////////////////////////

license {
  // Specify location of header to use in comparisons,
  // default to project.file('LICENSE')
  header file("${projectDir}/config/license/LICENSE")
  // Skip over files that have some header already, which might not be
  // the one specified in the header parameter, defaults to false
  skipExistingHeaders false
  // Prevent tasks from stopping the build, defaults to false
  ignoreFailures true
  // Be extra strict in the formatting of existing headers, defaults to false
  strictCheck true
  headerDefinitions {
    javadoc_style {
      firstLine = '/*'
      beforeEachLine = '  '
      endLine = '*/'
      afterEachLine = ''
      // skipLinePattern = ''
      firstLineDetectionPattern = '(\\s|\\t)*/\\*.*$'
      lastLineDetectionPattern = '.*\\*/(\\s|\\t)*$'
      allowBlankLines = true
      isMultiline = true
      padLines = false
    }
    xml_style {
      firstLine = '<!--'
      beforeEachLine = '  '
      endLine = '-->'
      afterEachLine = ''
      skipLinePattern = '^<\\?xml.*>$'
      firstLineDetectionPattern = '(\\s|\\t)*<!--.*$'
      lastLineDetectionPattern = '.*-->(\\s|\\t)*$'
      allowBlankLines = true
      isMultiline = true
      padLines = false
    }
  }
  includes([
    './build.gradle',
    '**/*.groovy',
  ])
  excludes([
    '**/*.properties',
    '**/*.png',
  ])
  mapping([
    'java': 'JAVADOC_STYLE',
    'groovy': 'JAVADOC_STYLE',
    'fxml': 'XML_STYLE',
  ])
  ext {
    name = applicationName
    url = applicationUrl
    copyright = applicationCopyright
    licenseName = applicationLicenseName
    licenseType = applicationLicenseType
  }
}

checkstyle {
  // The version of the code quality tool to be used.
  toolVersion = checkstyleVersion

  // The Checkstyle configuration file to use.
  // https://github.com/checkstyle/checkstyle/tree/master/src/main/resources
  configFile = file("${projectDir}/config/checkstyle/google_checks.xml")

  // Whether to allow the build to continue if there are warnings.
  ignoreFailures = true

  // The maximum number of errors that are tolerated before breaking
  // the build or setting the failure property.
  // maxErrors = 20

  // The maximum number of warnings that are tolerated before breaking
  // the build or setting the failure property.
  // maxWarnings = 50

  // Whether rule violations are to be displayed on the console.
  showViolations = true

  // The directory where reports will be generated.
  // reportsDir = file("${project.reporting.baseDir}/checkstyle")
}

pmd {
  // The version of the code quality tool to be used.
  toolVersion = pmdVersion

  // Whether or not to write PMD results to System.out.
  consoleOutput = false

  // Whether to allow the build to continue if there are warnings.
  ignoreFailures = true

  // The directory where reports will be generated.
  // reportsDir = file("${project.reporting.baseDir}/pmd")

  // The rule priority threshold; violations for rules with a lower priority
  // will not be reported.
  // rulePriority = 5 // all violations will be reported

  // The target jdk to use with pmd.
  // targetJdk = sourceCompatibility

  // The custom rule set files to be used.
  // If you want to only use custom rule sets, you must clear ruleSets.
  ruleSetFiles = files("${projectDir}/config/pmd/ruleset.xml")

  // The built-in rule sets to be used.
  // See the official list of built-in rule sets:
  // https://pmd.github.io/pmd-6.21.0/pmd_rules_java.html
  ruleSets = [
    // 'category/java/bestpractices.xml',
    // 'category/java/codestyle.xml',
    // 'category/java/design.xml',
    // 'category/java/documentation.xml',
    // 'category/java/errorprone.xml',
    // 'category/java/multithreading.xml',
    // 'category/java/performance.xml',
    // 'category/java/security.xml',
  ]
}

cpd {
  // The version of the code quality tool to be used.
  toolVersion = pmd.toolVersion
  encoding = defaultEncoding
  ignoreFailures = true
  ignoreAnnotations = false
  ignoreIdentifiers = false
  ignoreLiterals = false
  minimumTokenCount = 50
  skipDuplicateFiles = false
  skipLexicalErrors = false
}

cpdCheck {
  exclude '**/*.groovy'
  exclude '**/*.css'
  reports {
    text.enabled = true
    xml.enabled = true
  }
  // Generate HTML output.
  // Stylesheet file could be downloaded from:
  // https://github.com/pmd/pmd/blob/master/pmd-core/etc/xslt/cpdhtml.xslt
  // Remove "illegal" attribute 'xpath-default-namespace' from this file:
  // xpath-default-namespace="http://pmd.sourceforge.net/report/2.0.0"
  // change "//duplication[@lines>30]" to "//duplication[@lines>10]"
  // and placed into ${projectDir}/config/cpd/xsl directory.
  doLast {
    def configDir = new File("${projectDir}/config/cpd/xsl")
    def reportDir = new File("${project.reporting.baseDir}/cpd")
    def xslFile = new File(configDir, 'cpdhtml.xslt')
    def xsl = new javax.xml.transform.stream.StreamSource(
        new StringReader(xslFile.getText()))
    def transformer = javax.xml.transform.TransformerFactory.newInstance()
        .newTransformer(xsl)
    def xmlTree = fileTree(dir: reportDir, include: '*.xml')
    xmlTree.getFiles().each {
      def baseFileName = it.name.take(it.name.lastIndexOf('.xml'))
      def textFileName = baseFileName + '.text'
      def textFile = new File(it.getParentFile(), textFileName)
      if (textFile.size()) {
        def htmlFileName = baseFileName + '.html'
        def htmlFile = new File(it.getParentFile(), htmlFileName)
        def html = new javax.xml.transform.stream.StreamResult(
            new FileOutputStream(htmlFile))
        def xml = new javax.xml.transform.stream.StreamSource(
            new StringReader(it.getText()))
        println "See the html report at: ${htmlFile}"
        transformer.transform(xml, html)
      }
    }
  }
}

task groovyCpdCheck(type: de.aaschmid.gradle.plugins.cpd.Cpd) {
  language = 'groovy'
  source = sourceSets.main.allGroovy
  reports {
    text.enabled = true
    xml.enabled = true
  }
  // Generate HTML output.
  // Stylesheet file could be downloaded from:
  // https://github.com/pmd/pmd/blob/master/pmd-core/etc/xslt/cpdhtml.xslt
  // Remove "illegal" attribute 'xpath-default-namespace' from this file:
  // xpath-default-namespace="http://pmd.sourceforge.net/report/2.0.0"
  // change "//duplication[@lines>30]" to "//duplication[@lines>10]"
  // and placed into ${projectDir}/config/cpd/xsl directory.
  doLast {
    def configDir = new File("${projectDir}/config/cpd/xsl")
    def reportDir = new File("${project.reporting.baseDir}/cpd")
    def xslFile = new File(configDir, 'cpdhtml.xslt')
    def xsl = new javax.xml.transform.stream.StreamSource(
        new StringReader(xslFile.getText()))
    def transformer = javax.xml.transform.TransformerFactory.newInstance()
        .newTransformer(xsl)
    def xmlTree = fileTree(dir: reportDir, include: '*.xml')
    xmlTree.getFiles().each {
      def baseFileName = it.name.take(it.name.lastIndexOf('.xml'))
      def textFileName = baseFileName + '.text'
      def textFile = new File(it.getParentFile(), textFileName)
      if (textFile.size()) {
        def htmlFileName = baseFileName + '.html'
        def htmlFile = new File(it.getParentFile(), htmlFileName)
        def html = new javax.xml.transform.stream.StreamResult(
            new FileOutputStream(htmlFile))
        def xml = new javax.xml.transform.stream.StreamSource(
            new StringReader(it.getText()))
        println "See the html report at: ${htmlFile}"
        transformer.transform(xml, html)
      }
    }
  }
}

check.dependsOn groovyCpdCheck

// SpotBugs reported failures: org.gradle.api.GradleException:
// Verification failed: SpotBugs violation found: 3
// at com.github.spotbugs.snom.internal.SpotBugsRunnerForWorker$
// SpotBugsExecutor.execute(SpotBugsRunnerForWorker.java:97) ...
spotbugs {
  // The version of the code quality tool to be used.
  toolVersion = spotbugsVersion

  // The source sets to be analyzed as part of the check and build tasks.
  // sourceSets = [
  //   sourceSets.main,
  // ]

  // Whether or not to allow the build to continue if there are warnings.
  ignoreFailures = true
  
  // Whether or not to show stack traces.
  showStackTraces = false

  // Whether or not to show progress.
  showProgress = false

  // The directory where reports will be generated.
  // reportsDir = file("${project.reporting.baseDir}/spotbugs")

  // The analysis effort level. The value specified should be one of
  // min, default, or max. Higher levels increase precision and find more
  // bugs at the expense of running time and memory consumption.
  effort = 'max'

  // The priority threshold for reporting bugs. If set to low, all bugs
  // are reported. If set to medium (the default), medium and high priority
  // bugs are reported. If set to high, only high priority bugs are reported.
  reportLevel = 'low'

  // The bug detectors which should be run. The bug detectors are specified
  // by their class names, without any package qualification. By default, all
  // detectors which are not disabled by default are run.
  // visitors = [
  //   'FindSqlInjection',
  //   'SwitchFallthrough',
  // ]

  // Similar to visitors except that it specifies bug detectors which should
  // not be run. By default, no visitors are omitted.
  // omitVisitors = [
  //   'FindNonShortCircuit',
  // ]

  // The filename of a filter specifying which bugs are reported.
  // includeFilter = file("${projectDir}/config/spotbugs/includeFilter.xml")

  // The filename of a filter specifying bugs to exclude from being reported.
  excludeFilter = file("${projectDir}/config/spotbugs/excludeFilter.xml")

  // onlyAnalyze = [
  //   'com.foobar.MyClass',
  //   'com.foobar.mypkg.*'
  // ]

  // maxHeapSize = '1g'

  extraArgs = [
    '-nested:false'
  ]

  jvmArgs = [
    '-Duser.language=ru'
  ]
}

tasks.withType(com.github.spotbugs.snom.SpotBugsTask) {
  reports {
    xml {
      enabled = false
    }
    html {
      enabled = true
      stylesheet = 'fancy-hist.xsl'
    }
  }
}

jacoco {
  // Version of Jacoco JARs to use.
  toolVersion = jacocoVersion

  // The directory where reports will be generated.
  // reportsDirectory = file("${project.reporting.baseDir}/jacoco")
}

jacocoTestReport {
  reports {
    xml.required = true
    xml.destination file("${project.reporting.baseDir}/jacoco/report.xml")
    csv.required = false
    html.destination file("${project.reporting.baseDir}/jacoco/html")
  }
}

build.dependsOn jacocoTestReport

codenarc {
  toolVersion = codenarcVersion
  configFile = file("${projectDir}/config/codenarc/rules.groovy")
  ignoreFailures = true
  maxPriority1Violations = 0
  maxPriority2Violations = 0
  maxPriority3Violations = 0
  reportsDir = file("${project.reporting.baseDir}/codenarc")
  reportFormat = 'html'
}

buildDashboard {
  reports {
    html {
      destination file("${project.reporting.baseDir}")
    }
  }
}
buildDashboard.dependsOn projectReport

////////////////////////////////////////////////////////////////////////////////

jlink {
  // The path to the JDK providing the tools needed
  // javaHome = System.getenv('JAVA_HOME')

  // The name of the Gradle dependency configuration used to
  // execute your application.
  // defaultValue: 'runtimeClasspath'
  // configuration = 'runtimeClasspath'

  // The directory into which the custom runtime image should be generated.
  // If you use the targetPlatform method to generate images for
  // other platforms, the corresponding images will be created in
  // subdirectories of imageDir.
  imageDir = file("${jlinkImageDir}")

  // The file into which a zip archive of the custom runtime image
  // should be created.
  // imageZip = file(
  //     "${jlinkDir}/${applicationLauncherName}-${project.version}.zip")

  // Convenience property for setting the values
  // of both imageDir and imageZip as follows:
  // imageDir <- buildDir/imageName
  // imageZip <- buildDir/imageName.zip
  // imageName = applicationLauncherName

  // The path to the base directory that will be used by the plugin
  // to store intermediate outputs.
  // defaultValue: "${buildDir}/jlinkbase"
  jlinkBasePath = "${jlinkDir}/temp"

  // The main class to be provided as part of the --launcher option of jlink.
  // defaultValue: project.mainClassName from the Application plugin
  mainClass = applicationClassName

  // The module name of this application.
  // defaultValue: the module name specified in the module-info.java
  moduleName = applicationModuleName

  // The name of the merged module.
  // defaultValue: moduleName.merged.module
  // mergedModuleName = "${moduleName}.merged.module"

  // The base name of the jar containing the merged module.
  // defaultValue: archiveBaseName.merged.module
  // mergedModuleJarName = "${archiveBaseName}.merged.module"

  // The version of the jar containing the merged module.
  // defaultValue: project.version
  // mergedModuleJarVersion = version

  // A list of options to be passed to jlink.
  options = [
    '--strip-native-commands',
    '--strip-debug',
    '--no-header-files',
    '--no-man-pages',
    '--compress', '2',
  ]

  // addOptions(String... options)
  // Adds options to be passed to jlink. It is an alternative way of
  // setting the options property. You can call this method multiple times.
  // addOptions '--no-header-files', '--no-man-pages'

  // Include all dependencies matching the given prefixes into
  // the merged module. This method is useful when it should handle one or
  // more modular jars as non-modular. You can call this method multiple
  // times.
  // forceMerge(String... jarPrefixes)

  // addExtraDependencies(String... jarPrefixes)
  // Instructs the plugin to treat all jars matching the given prefixes
  // as dependencies of the merged module.
  // A typical situation where this method is needed involves libraries
  // using JavaFX. Some libraries do not specify their JavaFX dependencies,
  // because JavaFX was part of the JDK before being removed in Java 11.
  // Including addExtraDependencies("javafx") into the jlink block solves
  // this problem.
  // addExtraDependencies 'javafx'

  // addExtraModulePath(String modulePath)
  // Instructs the plugin to include the specified modulePath in the list of
  // paths passed to the --module-path option of jlink.
  // You can call this method multiple times.
  // addExtraModulePath '/usr/lib/jmods'

  // targetPlatform(String name, String jdkHome, List<String> options = [])
  // targetPlatform(
  //   'linux-s390x',
  //   '/usr/lib/jvm/jdk_s390x_linux_hotspot_11_28',
  //   [
  //       '--endian', 'big'
  //   ]
  // )

  // targetPlatform(String name, Action<TargetPlatform> action)
  // targetPlatform("linux-s390x") {
  //   jdkHome = "/usr/lib/jvm/linux-s390x/jdk-11.0.2+9"
  //   addOptions("--endian", "big")
  //   addExtraModulePath("/usr/lib/openjfx/linux-s390x/jmods")
  // }

  // mergedModule {
  //   version
  //   additive
  //   excludeRequires(String... modules)
  //   excludeUses(String... services)
  //   excludeProvides(Map constraints)
  // }
  // mergedModule {
  //   additive = true
  //   requires 'java.desktop'
  //   requires transitive 'java.sql'
  //   uses 'java.sql.Driver'
  //   provides 'java.sql.Driver' with 'org.hsqldb.jdbc.JDBCDriver'
  //   excludeRequires 'java.compiler', 'java.rmi'
  //   excludeUses 'org.apache.logging.log4j.message.ThreadDumpMessage'
  //   excludeProvides servicePattern: 'org.apache.logging.*'
  // }

  launcher {
    moduleName = applicationModuleName
    mainClass = applicationClassName
    name = applicationLauncherName
    jvmArgs = applicationJvmArgs
    args = applicationArgs
    unixScriptTemplate = file("${jlinkTemplateNix}")
    windowsScriptTemplate = file("${jlinkTemplateWin}")
    // If true, the application will be launched without an associated
    // console window (using javaw instead of java).
    // defaultValue: false
    // noConsole = true
  }

  // The plugin can generate script files for additional applications
  // besides the main one. For each additional application you configure
  // a secondaryLauncher block.
  // This block supports all properties of the launcher block and also
  // the following ones:
  //
  // mainClass - the main class of this additional application
  // moduleName - the module containing the main class (default value -
  //              the value of the moduleName property in the enclosing
  //              jlink extension
  // secondaryLauncher {
  //   moduleName = applicationModuleName
  //   mainClass = applicationClassName
  //   name = applicationLauncherName
  //   jvmArgs = applicationJvmArgs
  //   args = applicationArgs
  //   unixScriptTemplate = file("${jlinkTemplateNix}")
  //   windowsScriptTemplate = file("${jlinkTemplateWin}")
  //   // noConsole = false
  // }

  // By default, all application modules are included in the custom runtime
  // image. This block allows you to create a custom runtime image containing
  // only some of the application modules.
  // If the customImage block is empty, the plugin will create a JRE
  // containing only the JDK modules required by your application.
  // The plugin figures out by itself which JDK modules are needed,
  // but you can use the below property to request a different set of modules.
  // customImage {
  //   jdkModules = ['java.desktop', 'java.xml', 'jdk.unsupported']
  //   appModules = ['my.merged.module']
  // }

  // Create a platform-specific application image and installer
  // https://openjdk.java.net/jeps/343
  jpackage {
    // The path to the JDK providing the jpackage tool.
    jpackageHome = System.getenv('JPACKAGE_HOME')

    // Convenience property for setting both imageOutputDir and
    // installerOutputDir with the value "${buildDir}/${outputDir}".
    // defaultValue: "jpackage"
    // outputDir = "${jpackageDir}"

    // The directory passed as argument to the --output option of jpackage
    // when executing the jpackageImage task.
    // defaultValue: buildDir/outputDir
    // imageOutputDir = file("${jpackageImageDir}")

    // The argument passed to the --name option when executing the
    // jpackageImage task.
    // defaultValue: the name value configured in the launcher block
    // or project.name
    imageName = platformImageName

    // List of additional options to be passed to the jpackage executable
    // when executing the jpackageImage task.
    // defaultValue: empty list
    imageOptions = [
      // Input dir
      '--input', jpackageInputDir,
      // Copyright for the application
      '--copyright', applicationCopyright,
      // Description of the application
      '--description', applicationDescription,
      // Vendor of the application
      '--vendor', applicationVendor,
      // Path of the icon of the application bundle (absolute path
      // or relative to the current directory)
      '--icon', "${jpackageResourcesDir}/${platformImageName}.${platformIconExtension}",
      '--add-launcher', "${platformLauncherName}-cli=${jpackageResourcesDir}/${platformLauncherName}-cli.launcher.properties"
    ]


    // The directory passed as argument to the --resource-dir option
    // when running jpackage to create an application installer.
    // It is also applicable when creating an application image
    // when you want your own application image
    // instead of the default java image.
    resourceDir = file("${jpackageResourcesDir}")

    // Boolean value that lets you generate only the platform-specific
    // application image and skip the generation of the platform-specific
    // application installer.
    // defaultValue: false
    skipInstaller = false

    // The type of the installer to create. Valid values are: "exe",
    // "msi", "rpm", "deb", "pkg", "dmg". If this option is not
    // specified (in create-installer mode) all supported types of
    // installable packages for the current platform will be created.
    // installerType = 'msi'

    // The directory passed as argument to the --output option when running
    // jpackage when executing the jpackage task.
    // defaultValue: ${buildDir}/${outputDir}
    // installerOutputDir = file("${jpackageImageDir}")

    // The argument passed to the --name option when running jpackage
    // when executing the jpackage task.
    // defaultValue: the name value configured in the launcher block or
    // project.name
    installerName = platformImageName

    // The argument passed to the --app-version option when running
    // jpackage when executing the jpackage and jpackageImage tasks.
    // defaultValue: the project version
    appVersion = applicationVersion

    // List of JVM arguments to be passed to the virtual machine.
    // defaultValue: the jvmArgs value configured in the launcher block or
    // an empty list
    jvmArgs = platformJvmArgs + [
      "-splash:\$APPDIR/${applicationSplashImage}"
    ]

    // List of arguments to be passed to the application.
    // defaultValue: the args value configured in the launcher block or
    // an empty list
    args = platformArgs

    // List of additional options to be passed to the jpackage executable
    // when executing the jpackage task.
    // defaultValue: empty list
    installerOptions = [
      // Verbose mode
      '--verbose',
      // Copyright for the application
      '--copyright', applicationCopyright,
      // Description of the application
      '--description', applicationDescription,
      // Vendor of the application
      '--vendor', applicationVendor,
      // Path to the license file (absolute path or relative to the
      // current directory)
      '--license-file', applicationLicenseFile,
      // Path to a Properties file that contains list of
      // key, value pairs (absolute path or relative to the
      // current directory). The keys: "extension", "mime-type",
      // "icon", and "description" can be used to describe the
      // association. This option can be used multiple times.
      '--file-associations', "${jpackageConfigDir}/associations.properties",
    ]
    if (platformInstallDir) {
      installerOptions += [
        // Absolute path of the installation directory of the
        // application on OS X or Linux. Relative sub-path of the
        // installation location of the application such as
        // "Program Files" or "AppData" on Windows.
        '--install-dir', "${platformInstallDir}",
      ]
    }

    // This property is required only when using the targetPlatform method.
    // It specifies which of the images produced by jlink should be used as
    // runtime image by jpackage. Its value must match the name provided
    // in one of the calls to the targetPlatform method.
    // defaultValue: null
    // targetPlatformName = "linux"

    switch (platformFamily) {
      case 'mac':
        imageOptions += [

          // Name of the application as it appears in the menu bar
          // (defaults to the application name; must be less than 16
          // characters long and be suitable for displaying in the
          // menu bar and the application Info window)
          '--mac-package-name', platformImageName,

          // An identifier that uniquely identifies the application
          // for macOS (defaults to the main class name; limited to
          // alphanumeric, hyphen, and period characters)
          '--mac-package-identifier', applicationModuleName,

          // Request that the bundle be signed
          // '--mac-sign',

          // Path of the keychain to search for the signing identity
          // (defaults to the standard keychains)
          // '--mac-signing-keychain <file path>',

          // Team name portion of the Apple signing identity
          // (for example, "Developer ID Application: ")
          // '--mac-signing-key-user-name <team name>',

          // When signing the application bundle, the value prepended
          // to all components that need to be signed but don't have
          // an existing bundle identifier
          // '--mac-bundle-signing-prefix <prefix string>',
        ]
        break
      case 'windows':
        imageOptions += [
          // Creates a console launcher for the application (should
          // be specified for applications which require console
          // interactions)
          // '--win-console',
        ]
        installerOptions += [
          // Adds a dialog to enable the user to choose a directory
          // in which to install the application
          '--win-dir-chooser',

          // Adds the application to the system menu
          '--win-menu',

          // Start Menu group in which to place this application
          '--win-menu-group', platformMenuGroup,

          // Install the application on a per-user basis
          '--win-per-user-install',

          // Create a desktop shortcut for the application
          '--win-shortcut',

          // UUID associated with upgrades for this package
          '--win-upgrade-uuid', platformUUID
        ]
        // The type of the installer to create. Valid values are: "exe",
        // "msi", "rpm", "deb", "pkg", "dmg". If this option is not
        // specified (in create-installer mode) all supported types of
        // installable packages for the current platform will be
        // created.
        installerType = 'msi'
        break
      case 'linux':
        installerOptions += [
          // Name for the Linux package, defaults to the
          // application name
          // '--linux-package-name', applicationLauncherName,

          // Maintainer for .deb bundle
          '--linux-deb-maintainer', applicationAuthorName + ' <' + applicationAuthorEmail + '>',

          // Menu group this application is placed in
          '--linux-menu-group', platformMenuGroup,

          // Required packages or capabilities for the application
          // '--linux-package-deps',

          // Release value of the RPM spec file, or the Debian
          // revision value of the DEB control file
          // '--linux-app-release', '',

          // Creates a shortcut for the application
          '--linux-shortcut',

          // Group value of the RPM spec file, or the Section
          // value of the DEB control file
          '--linux-app-category', 'utils',

          // Type of the license ("License: " of the RPM .spec)
          '--linux-rpm-license-type', applicationLicenseType,
        ]
        // The type of the installer to create. Valid values are: "exe",
        // "msi", "rpm", "deb", "pkg", "dmg". If this option is not
        // specified (in create-installer mode) all supported types of
        // installable packages for the current platform will be
        // created.
        // installerType = 'deb'
        break
    }
  }
}

////////////////////////////////////////////////////////////////////////////////

// Explicit dependencies for compatibility with Gradle 8.0
[
  build,
  compileJava,
  compileTestJava,
  compileTestGroovy,
  processResources,
  processTestResources,
  processFilteredResources,
  processFilteredTestResources,
  checkstyleMain,
  checkstyleTest,
  codenarcTest,
  licenseMain,
  licenseTest,
  cpdCheck,
  pmdMain,
  pmdTest,
  spotbugsMain,
  spotbugsTest, 
  distTar,
  distZip,
  jar,
  javadoc,
  startScripts,
].each { it.configure { dependsOn processCommonResources } }

defaultTasks 'build'
